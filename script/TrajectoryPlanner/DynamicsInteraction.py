#!/usr/bin/env python

"""
Python program that calculates the necessary constants needed to find bounds on alpha and PID gains. Running this file
generates a .csv file containing all these constants as well as the bounds on alpha.

Date 2/2/2021
"""


import sys
import csv
import numpy as np
import scipy.optimize
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from matplotlib import colors
from sympy import symbols, Eq, solve

import klampt
from SuspensionMatrices import Suspension_8legs

# NOTE: Edit for specific robot
FILEPATH = './robot_sim.xml'
FILEPATH_INTERACTION_CSV = './DynamicsInteractionConstants.csv'
FILEPATH_DEFAULT_CSV = './GenerateGainsConstants_default.csv'

# Function: Extract Data
# Extracts data from the .csv file generated by GenerateConstants.py
def ExtractData_GainBounds():
    with open(FILEPATH_DEFAULT_CSV, 'rb') as myfile:
        csvreader = csv.reader(myfile, delimiter=',')
        data = []
        for row in csvreader:
            data.append(row)

    constants = [None] * 14
    for k in range(1,len(constants)+1):
        constants[k-1] = float(data[k][1])

    alpha = float(data[24][1])
    K_I = float(data[25][1])

    return constants, alpha, K_I


# Function: Max Eigenvalue H
# Returns the maximum eigenvalue of the H matrix for a given state. Used with minimizer to find maximum possible
# eigenvalue of the H matrix
def FindMaxEigH(var_init, robot, sus):
    state = [0, 0, var_init[0], 0]
    state.extend(var_init[1:])
    robot.setConfig(state)
    H_array = np.asarray(robot.getMassMatrix())
    H = np.delete(H_array, [0,1,3], 0)
    H = np.delete(H, [0,1,3], 1)
    w, v = np.linalg.eig(H)
    return -max(w)


def FindKtau(var_init, robot, sus, contact_pt, Kenv):
    list_dtaudx = []
    list_max = []

    x = [0, 0, var_init[0], 0] + list(var_init[1:len(var_init)])  # roll pitch 4dof
    dx = 0.001 # [0, 0, 0, 0] + list(var_init[len(var_init)/2:len(var_init)])
    x_original = x[:]

    for j in range(4, len(x)):
        x = x_original[:]

        robot.setConfig(x)
        J1 = np.asarray(link4.getPositionJacobian([0, 0, 0]))
        J1 = np.delete(J1, [0,1,2,3,9], 1)
        J1_trans = np.transpose(J1)
        pos1 = link4.getWorldPosition([0,0,0])

        # full joint coord: (qroll, qpitch, q1, q2, q3)
        tau_ext1 = -np.linalg.multi_dot([J1_trans, Kenv, pos1-contact_pt])

        x[j] = x[j] + dx

        robot.setConfig(x)
        J2 = np.asarray(link4.getPositionJacobian([0, 0, 0]))
        J2 = np.delete(J2, [0,1,2,3,9], 1)
        J2_trans = np.transpose(J2)
        pos2 = link4.getWorldPosition([0, 0, 0])

        tau_ext2 = -np.linalg.multi_dot([J2_trans, Kenv, pos2-contact_pt])

        for i in range(len(tau_ext1)):
            dtaudx = abs((tau_ext2[i]-tau_ext1[i])/dx)
            list_dtaudx.append(dtaudx)

        list_max.append(np.amax(list_dtaudx))
        list_dtaudx = []

    return -max(list_max)


def constraint_fun(var_init):
    x = [0, 0, var_init[0], 0] + list(var_init[1:len(var_init)])
    robot.setConfig(x)
    pos = link4.getWorldPosition([0, 0, 0])
    dist_vec = np.asarray(pos - contact_pt)
    dist_mag = np.linalg.norm(dist_vec)

    return dist_mag


def FindMaxTau(var_init, robot, sus, contact_pt, Kenv):
    x = [0, 0, var_init[0], 0]
    x.extend(var_init[1:])
    robot.setConfig(x)
    pos = link4.getWorldPosition([0, 0, 0])

    J = np.asarray(link4.getPositionJacobian([0,0,0]))
    J = np.delete(J, [0,1,2,3,9], 1)
    J_trans = np.transpose(J)

    tau_ext = -np.linalg.multi_dot([J_trans, Kenv, pos - contact_pt])

    return -np.linalg.norm(tau_ext)


def FindMaxPs(robot, sus, contact_pt, Kenv, task_sphere_rad):
    maxrowsum = np.amax(np.sum(Kenv, axis=1))

    return 0.5 * maxrowsum * (task_sphere_rad**2)



def GetConstants(robot, sus, Kenv, contact_pt, task_sphere_rad):
    # Initializing state vectors
    # full state: (x, y, z, qyaw, qroll, qpitch, q1, q2, q3, q4)
    x_init = [0] * robot.numLinks()
    dx_init = [0.1] * robot.numLinks()
    states = x_init + dx_init


    # Initializing lower and upper bounds of robot DOFs
    lowerbounds = [-0.1, -np.pi / 4, -np.pi / 4, -np.pi, -np.pi, -1.0472, 0]
    upperbounds = [0.1, np.pi / 4, np.pi / 4, np.pi, 0, 2.6, 0]
    bnds = scipy.optimize.Bounds(lowerbounds, upperbounds)

    # Initialize nonlinear constraint based on task sphere radius
    cf = scipy.optimize.NonlinearConstraint(constraint_fun, 0, task_sphere_rad)

    # CALCULATING Ktau (qroll, qpitch, 4 DOF) states[4:robot.numLinks()]
    print "Calculating K_tau..."
    res_Ktau = scipy.optimize.minimize(FindKtau, states[2:3] + states[4:robot.numLinks()],
                                       args=(robot, sus, contact_pt, Kenv),
                                       bounds=bnds, constraints=cf)
    stateKtau = res_Ktau.x
    kTau = -res_Ktau.fun
    print res_Ktau.message

    # Calculating maxTau
    print "Calculating max tau_d..."
    res_maxTau = scipy.optimize.minimize(FindMaxTau, states[2:3] + states[4:robot.numLinks()],
                                         args=(robot, sus, contact_pt, Kenv),
                                         bounds=bnds, constraints=cf)
    stateMaxTau = res_maxTau.x
    maxTau = -res_maxTau.fun

    # Calculating maxPs
    print "Calculating max Ps..."
    maxPs = FindMaxPs(robot, sus, contact_pt, Kenv, task_sphere_rad)

    return kTau, maxTau, maxPs, res_Ktau.success


# Function: Main
# Running this main function will generate the constants and alpha bounds and then output a .csv file containing these
# values (for future plotting, etc).
if __name__ == "__main__":
    # Upload URDF file, klampt models.
    world = klampt.WorldModel()
    res = world.readFile(FILEPATH)

    robot = world.robot(0)
    sus = Suspension_8legs()
    print "Number of DOFs: " + str(robot.numLinks())
    print "Number of Links: " + str(robot.numDrivers())

    # Getting the end effector link of the robot assembly
    link4 = robot.link(robot.numLinks()-1)

    # Extract current data from the .csv file generated from GenerateConstants.py
    c, _, _ = ExtractData_GainBounds()
    maxEigH, minEigH, maxG, kG, kK, kB, kX, maxEigK, maxEigB, minEigK_p, minEigB_p, kC, k, total_mass =\
        c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13]


    # Initializing environmental stiffness matrix
    stiffness = 100
    stiffness_list = [x * 1 for x in range(1, 301)]

    # Define contact point
    contact_pt = np.asarray([0.542, -0.10475, 0])

    # Initializing constraint based on sphere of task space
    task_radius = 0.1
    task_radius_list = [x * 0.002 for x in range(1, 201)]

    with open(FILEPATH_INTERACTION_CSV, 'w') as myfile:
        csvwriter = csv.writer(myfile, delimiter=',')
        csvwriter.writerow(["task_radius", "stiffness", "kTau", "maxTau", "maxPs", "k", "alpha1",
                            "alpha2_r1", "alpha2_r2", "alpha2_r3", "alpha2_r4"])

        # for task_radius in task_radius_list:
        for stiffness in stiffness_list:
            print "Task radius: " + str(task_radius)
            print "Stiffness: " + str(stiffness)

            # Set K_environment stiffness
            K_environment = np.asarray([[stiffness, 0, 0], [0, stiffness, 0], [0, 0, stiffness]])

            # Save k value
            k_orig = k

            # Get constants, adjust k
            kTau, maxTau, maxPs, success = GetConstants(robot, sus, K_environment, contact_pt, task_radius)
            k = k + kTau
            # print kTau

            # CALCULATING ALPHA BOUNDS
            alphas = []
            alpha1 = ((minEigK_p - k) / maxEigH) ** 0.5
            alphas.append(alpha1)
            # print alpha1

            alpha2 = symbols('alpha2')
            eq = (alpha2 * maxEigH) + (((kK * kX) ** 2) / (4 * maxEigH * alpha2 ** 3)) - minEigB_p
            sol = solve(eq)
            for m in range(len(sol)):
                alphas.append(sol[m])

            if success:
                csvwriter.writerow([task_radius, stiffness, kTau, maxTau, maxPs, k] + alphas)

            # Reset k
            k = k_orig

    print "\nCSV file generated, script complete"

    


