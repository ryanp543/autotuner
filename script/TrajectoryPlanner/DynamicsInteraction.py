#!/usr/bin/env python

"""
Python program that calculates the necessary constants needed to find bounds on alpha and PID gains. Running this file
generates a .csv file containing all these constants as well as the bounds on alpha.

Date 2/2/2021
"""


import sys
import csv
import numpy as np
import scipy.optimize
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from matplotlib import colors
from sympy import symbols, Eq, solve

import klampt
from SuspensionMatrices import Suspension_8legs

# NOTE: Edit for specific robot
FILEPATH = './robot_sim.xml'
FILEPATH_MASS_CSV = './DynamicsMassConstants.csv'
FILEPATH_DEFAULT_CSV = './GenerateGainsConstants_default.csv'

# Function: Extract Data
# Extracts data from the .csv file generated by GenerateConstants.py
def ExtractData_GainBounds():
    with open(FILEPATH_DEFAULT_CSV, 'rb') as myfile:
        csvreader = csv.reader(myfile, delimiter=',')
        data = []
        for row in csvreader:
            data.append(row)

    constants = [None] * 14
    for k in range(1,len(constants)+1):
        constants[k-1] = float(data[k][1])

    alpha = float(data[24][1])
    K_I = float(data[25][1])

    return constants, alpha, K_I


# Function: Max Eigenvalue H
# Returns the maximum eigenvalue of the H matrix for a given state. Used with minimizer to find maximum possible
# eigenvalue of the H matrix
def FindMaxEigH(var_init, robot, sus):
    state = [0, 0, var_init[0], 0]
    state.extend(var_init[1:])
    robot.setConfig(state)
    H_array = np.asarray(robot.getMassMatrix())
    H = np.delete(H_array, [0,1,3], 0)
    H = np.delete(H, [0,1,3], 1)
    w, v = np.linalg.eig(H)
    return -max(w)


def FindKtau(var_init, robot, sus, contact_pt):
    list_dtaudx = []
    list_max = []

    x = [0, 0, var_init[0], 0] + list(var_init[1:len(var_init)])  # roll pitch 4dof
    dx = 0.001 # [0, 0, 0, 0] + list(var_init[len(var_init)/2:len(var_init)])
    x_original = x[:]

    for j in range(4, len(x)):
        x = x_original[:]

        robot.setConfig(x)
        J1 = np.asarray(link4.getPositionJacobian([0, 0, 0]))
        J1 = np.delete(J1, [0,1,2,3,9], 1)
        J1_trans = np.transpose(J1)
        pos1 = link4.getWorldPosition([0,0,0])

        # full joint coord: (qroll, qpitch, q1, q2, q3)
        tau_ext1 = -np.linalg.multi_dot([J1_trans, Kenv, pos1-contact_pt])

        x[j] = x[j] + dx

        robot.setConfig(x)
        J2 = np.asarray(link4.getPositionJacobian([0, 0, 0]))
        J2 = np.delete(J2, [0,1,2,3,9], 1)
        J2_trans = np.transpose(J2)
        pos2 = link4.getWorldPosition([0, 0, 0])

        tau_ext2 = -np.linalg.multi_dot([J2_trans, Kenv, pos2-contact_pt])

        for i in range(len(tau_ext1)):
            dtaudx = abs((tau_ext2[i]-tau_ext1[i])/dx)
            list_dtaudx.append(dtaudx)

        list_max.append(np.amax(list_dtaudx))
        list_dtaudx = []

    return -max(list_max)


def constraint_fun(var_init):
    x = [0, 0, var_init[0], 0] + list(var_init[1:len(var_init)])
    robot.setConfig(x)
    pos = link4.getWorldPosition([0, 0, 0])
    dist_vec = np.asarray(pos - contact_pt)
    dist_mag = np.linalg.norm(dist_vec)

    return dist_mag


# Function: Main
# Running this main function will generate the constants and alpha bounds and then output a .csv file containing these
# values (for future plotting, etc).
if __name__ == "__main__":
    # Upload URDF file, klampt models.
    world = klampt.WorldModel()
    res = world.readFile(FILEPATH)

    robot = world.robot(0)
    sus = Suspension_8legs()
    print "Number of DOFs: " + str(robot.numLinks())
    print "Number of Links: " + str(robot.numDrivers())

    # Getting the end effector link of the robot assembly
    link4 = robot.link(robot.numLinks()-1)

    # Extract current data from the .csv file generated from GenerateConstants.py
    c, _, _ = ExtractData_GainBounds()
    maxEigH, minEigH, maxG, kG, kK, kB, kX, maxEigK, maxEigB, minEigK_p, minEigB_p, kC, k, total_mass =\
        c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13]

    # Initializing environmental stiffness matrix
    Kenv = np.asarray([[100, 0, 0], [0, 100, 0], [0, 0, 100]])

    # Define contact point
    contact_pt = np.asarray([0.542, -0.10475, 0])

    # Initializing lower and upper bounds of robot DOFs
    lowerbounds = [-0.1, -np.pi/4, -np.pi/4, -np.pi, -np.pi, -1.0472, 0]
    upperbounds = [0.1, np.pi/4, np.pi/4, np.pi, 0, 2.6, 0]
    bnds = scipy.optimize.Bounds(lowerbounds, upperbounds)

    # Initializing constraint based on sphere of task space
    task_sphere_rad = 0.1
    cf = scipy.optimize.NonlinearConstraint(constraint_fun, 0, task_sphere_rad)

    # Initializing state vectors
    # full state: (x, y, z, qyaw, qroll, qpitch, q1, q2, q3, q4)
    x_init = [0] * robot.numLinks()
    dx_init = [0.1] * robot.numLinks()
    states = x_init + dx_init

    # CALCULATING Ktau (qroll, qpitch, 4 DOF) states[4:robot.numLinks()]
    print "Calculating K_tau..."
    res_Ktau = scipy.optimize.minimize(FindKtau, states[2:3]+states[4:robot.numLinks()], args=(robot,sus,contact_pt),
                                       bounds=bnds, constraints=cf)
    stateKtau = res_Ktau.x
    kTau = -FindKtau(stateKtau, robot, sus, contact_pt)
    print kTau

    # Adjusting k
    k = k + k_tau

    # CALCULATING ALPHA BOUNDS
    alphas = []
    alpha1 = ((minEigK_p - k) / maxEigH) ** 0.5
    alphas.append(alpha1)

    print alpha1

    alpha2 = symbols('alpha2')
    eq = (alpha2 * maxEigH) + (((kK * kX) ** 2) / (4 * maxEigH * alpha2 ** 3)) - minEigB_p
    sol = solve(eq)
    for k in range(len(sol)):
        alphas.append(sol[k])

    


